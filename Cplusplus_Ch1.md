# C++ Ch1

## 객체, 초기화, 할당

+ 객체는 값을 저장하고 사용할 수 있는 '메모리 조각' 이다. 정보를 저장하고 검색할 수 있는 메일박스 처럼 생각할 수 있다. 모든 컴퓨터에는 프로그램에서 사용할 수 있는 RAM이라는 메모리가 있다. 객체가 정의되면 __해당 메모리의 조각들이 객체에 할당된다__. 

+ __변수__는 단순히 __이름을 가진 객체__다. 

  ```c++
  int x;
  ```

  + 위 명령문이 CPU에 의해 실행되면, RAM으로부터 메모리의 조각들이 객체에 할당된다. (인스턴스화)
  + 예를 들어 변수 X에 메모리 위치 140이 지정되었다고 가정한다면, 프로그램이 표현식이나 명령문에서 변수 X를 찾을 때마다 값을 얻기 위해 메모리 위치 140을 조사할 것이다. 
  + C++에서 변수는ㄴ __l-value__(대입 연산자의 피연산자 중 왼쪽에 위치)이다. l-valeu란, 메모리 상에서 지속적인 주소를 가진 값이다. 할당(assignment)를 수행할 때, 대입 연산자의 왼쪽 편은 l-value이어야 한다. 

+ 초기화되지 않은 변수
  C++에서는 변수를 자동으로 어떤 기본값으로 초기화하지 않는다. 변수가 컴파일러에 의해 메모리 위치가 할당되면, 그 변수의 기본값(default value)는 이미 그 메모리 위치에 할당되어 있는 쓰레기 값(garbage value)이 된다.





## 함수

+ 프로그램은 함수 호출을 만나면 함수 내에서 순차적으로 명령문을 실행한다. 함수 호출은 현재 실행하고 있는 함수를 인터럽트하고 호출한 함수를 실행하도록 CPU에 지시하는 식이다. 호출된 함수가 종료되면 CPU는 함수 호출 지점으로 돌아가서 이전 함수를 다시 실행한다. 
+ 프로그램이 실행되면 운영체제는 ```main()``` 함수 호출을 수행한다. main()의 맨 위로 이동한 뒤 순차적으로 실행한다. 마지막으로 ```main()``` 함수는 정수 값(일반적으로 0)을 운영체제에 반환한다. 이것이 main이 int main()으로 정의된 이유이다. 이 값을 __상태 코드(status code)__라고 하며, 프로그램이 성공적으로 실행되었는지를 알려준다. 규칙에 따라 반환 값 0은 성공을 의미하고 양수 값은 실패를 의미한다.



## 헤더파일

``` c++
#include <filename>
```

```<>```는 컴파일러와 함께 제공되는 헤더 파일을 include할 때 사용한다. 위 헤더 파일은 C++ 런타임 라이브러리의 헤더 파일로써 운영체제의 특별한 위치에 존재한다.

```c++
#include "filename"
```

```""``` 는 소스 파일이 있는 디렉토리에서 헤더 파일을 include 하도록 전처리기(preprocessor)에게 지시한다. 일반적으로 이와 같은 방법으로 자신이 작성한 헤더파일을 include한다. 



+ add.h 헤더파일, add.c 파일, main.cpp 파일이 있다고 한다면 이런식으로 컴파일 된다. 

  <img src = "https://user-images.githubusercontent.com/31370590/124135974-49669380-dabf-11eb-9b14-30457ecc432d.PNG" width = "600" height = "400">

  ➡ 각각의 cpp 파일은 목적파일을 만들어 내고, 이 목적파일을 링크해 실행파일을 만든다. 

  Q) 그러면 사용자가 정의한 헤더파일은 컴파일과정에서 cpp 파일에 포함되고, 컴파일러와 함께 제공되는 헤더파일(c++ 런타임 라이브러리)는 링킹 과정에서 실행파일에 포함되는 건가?



## 전처리기

+ 전처지리(preprocessor)는 프로그램을 컴파일 할 때 컴파일 직전에 실행되는 별도의 프로그램이다. 전처리기가 실행되면 각 코드 파일에서 지시자(directives)를 찾는다. 지시자(directives)는 #으로 시작해서 줄바꿈으로 끝나는 코드다. 

+ 전치리기는 컴파일러가 실행되기 직전에 단순히 텍스트를 조작하는 치환 역할을 하기도 하고, 디버깅에도 도움을 주며 헤더 파일의 중복 포함도 방지해준다. 

+ ```#define``` 지시자를 사용해서 매크로를 만들 수 있다. 매크로는 입력을 출력으로 변환하는 방식을 정의하는 규칙이다. 

  ```c++
  #define identifier
  #define identifier substitution_text
  ```

+ 전처리기가 이 지시자를 발견하면 'identifier'는 앞으로 'substitution_text' 텍스트로 대체된다. 식별자(identifier)는 일반적으로 공백을 나타내는 밑줄을 사용하여 대문자로 모두 입력한다. 

  ```c++
  #define MY_FAVORITE_NUMBER 9
  
  cout << "My favorite number is : " << MY_FAVORITE_NUMBER << endl; // 9
  ```

  

+ 조건부 컴파일
  조건부 컴파일 전처리 지시자를 사용하면 컴파일할 조건이나 컴파일 하지 않을 조건을 지정할 수 있다. ```#ifdef``` 지시자를 사용하면 전처리기가 이전에 ```#```이 정의되었는지 아닌지를 확인한다. 정의되었다면 ```#ifdef```와 해당 ```#endif``` 사이의 코드가 컴파일 된다.  그렇지 않으면 코드가 무시된다.  ```#ifndef```는 ```ifdef```의 반대다. 식별자가 아직 정의되지 않았는지 확인한다. 

  ```c++
  #define PRINT_JOE // PRINT_JOE 정의
  
  #ifdef PRINT_JOE 
  std::cout << "Joe" << std::endl;
  #endif 
  // PRINT_JOE가 정의되었기 때문에 이는 컴파일 된다.
  
  #ifdef PRINT_BOB 
  std::cout << "Bob" << std::endl; 
  #endif
  
  // PRINT_BOB은 정의되지 않았기 때문에 이는 컴파일 되지 않는다. 
  ```



## 헤더가드

```c++
#ifdef MATH_H
#define MATH_H

int getSquareSides(){
    return 4;
}

#endif
```

+ 위 헤더 파일이 include 되면, ```MATH_H```가 정의되었는지 확인한다. 헤더 파일을 처음 include 하면 ```MATH_H```는 정의되어 있지 않다. 그러므로 ```MATH_H```를 정의하고 헤더 파일의 내용을 include한다. 그러나 이전에 헤더파일을 include 했다면 ```MATH_H```는 이미 정의되어 있기 때문에 헤더 파일 내용이 무시된다. 
+ 현재 많은 최신 컴파일러는 ```#pragma``` 지시자를 이용한 단순한 헤더 가드를 지원한다.  ```#pragma once```는 헤더 가드와 같은 기능을 하며, 짧다는 게 장점이다. 



## 여러가지 초기화 방법

+ 대입 연산자(```=```)를 사용한 복사 초기화

  ```c++
  int nValue = 5;
  ```

+ 괄호(```()```)를 사용한 직접 초기화

  ```c++
  int nValue(5);
  ```

  직접 초기화는 일부 데이터 타입에서 복사 초기화보다 성능이 더 뛰어날 수 있다.  또한, 초기화와 할당을 구분하는데도 도움이 된다. 따라서 복사 초기화보다 직접 초기화를 사용하는 것이 좋다. 

+ 중괄호(```{}```)를 이용한 유니폼 초기화

  ```c++
  int value{5};
  int value{}; // 0으로 초기화
  int value{4.5} // 유니폼 초기화는 형 변환을 허용하지 않는다.
  ```

  



## 참고

+ [소년코딩](https://boycoding.tistory.com/145?category=1006674)

  위 글은 '소년코딩' 님의 블로그 글을 참고하여 작성하였습니다. 